"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStitchedSchemaFromSupergraphSdl = exports.getSubschemasFromSupergraphSdl = void 0;
const graphql_1 = require("graphql");
const executor_http_1 = require("@graphql-tools/executor-http");
const stitch_1 = require("@graphql-tools/stitch");
const utils_js_1 = require("./utils.js");
function getSubschemasFromSupergraphSdl({ supergraphSdl, onExecutor = ({ endpoint }) => (0, executor_http_1.buildHTTPExecutor)({ endpoint }), batch = false, }) {
    const ast = typeof supergraphSdl === 'string' ? (0, graphql_1.parse)(supergraphSdl) : supergraphSdl;
    const subgraphQueryFieldDefinitionNodes = new Map();
    const subgraphEndpointMap = new Map();
    const subgraphTypesMap = new Map();
    const typeNameKeyBySubgraphMap = new Map();
    const typeNameFieldsKeyBySubgraphMap = new Map();
    const typeNameCanonicalMap = new Map();
    (0, graphql_1.visit)(ast, {
        EnumTypeDefinition(node) {
            if (node.name.value === 'join__Graph') {
                node.values?.forEach(valueNode => {
                    const joinGraphDirectiveNode = valueNode.directives?.find(directiveNode => directiveNode.name.value === 'join__graph');
                    if (joinGraphDirectiveNode) {
                        const urlArgumentNode = joinGraphDirectiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'url');
                        if (urlArgumentNode?.value?.kind === graphql_1.Kind.STRING) {
                            subgraphEndpointMap.set(valueNode.name.value, urlArgumentNode.value.value);
                        }
                    }
                });
            }
            node.directives?.forEach(directiveNode => {
                if (directiveNode.name.value === 'join__type') {
                    const graphArgumentNode = directiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'graph');
                    if (graphArgumentNode?.value?.kind === graphql_1.Kind.ENUM) {
                        const graphName = graphArgumentNode.value.value;
                        const enumValueNodes = node.values?.filter(valueNode => {
                            const joinEnumValueDirectiveNode = valueNode.directives?.find(directiveNode => directiveNode.name.value === 'join__enumValue');
                            if (joinEnumValueDirectiveNode) {
                                const graphArgumentNode = joinEnumValueDirectiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'graph');
                                if (graphArgumentNode?.value?.kind === graphql_1.Kind.ENUM) {
                                    return graphArgumentNode.value.value === graphName;
                                }
                            }
                            return false;
                        }) || [];
                        const enumTypedDefNodeForSubgraph = {
                            ...node,
                            values: enumValueNodes,
                        };
                        let subgraphTypes = subgraphTypesMap.get(graphName);
                        if (!subgraphTypes) {
                            subgraphTypes = [];
                            subgraphTypesMap.set(graphName, subgraphTypes);
                        }
                        subgraphTypes.push(enumTypedDefNodeForSubgraph);
                    }
                }
            });
        },
        ObjectTypeDefinition(node) {
            if (node.name.value === 'Query') {
                node.fields?.forEach(fieldNode => {
                    fieldNode.directives?.forEach(directiveNode => {
                        if (directiveNode.name.value === 'join__field') {
                            const graphArgumentNode = directiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'graph');
                            if (graphArgumentNode?.value?.kind === graphql_1.Kind.ENUM) {
                                const graphName = graphArgumentNode.value.value;
                                let fieldDefinitionNodesOfSubgraph = subgraphQueryFieldDefinitionNodes.get(graphName);
                                if (!fieldDefinitionNodesOfSubgraph) {
                                    fieldDefinitionNodesOfSubgraph = [];
                                    subgraphQueryFieldDefinitionNodes.set(graphName, fieldDefinitionNodesOfSubgraph);
                                }
                                fieldDefinitionNodesOfSubgraph.push(fieldNode);
                            }
                        }
                    });
                });
            }
            node.directives?.forEach(directiveNode => {
                if (directiveNode.name.value === 'join__owner') {
                    const graphArgumentNode = directiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'graph');
                    if (graphArgumentNode?.value?.kind === graphql_1.Kind.ENUM) {
                        typeNameCanonicalMap.set(node.name.value, graphArgumentNode.value.value);
                    }
                }
                if (directiveNode.name.value === 'join__type') {
                    const graphArgumentNode = directiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'graph');
                    if (graphArgumentNode?.value?.kind === graphql_1.Kind.ENUM) {
                        let keyFieldName;
                        const graphName = graphArgumentNode.value.value;
                        const keyArgumentNode = directiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'key');
                        if (keyArgumentNode?.value?.kind === graphql_1.Kind.STRING) {
                            let typeNameKeyMap = typeNameKeyBySubgraphMap.get(graphName);
                            if (!typeNameKeyMap) {
                                typeNameKeyMap = new Map();
                                typeNameKeyBySubgraphMap.set(graphName, typeNameKeyMap);
                            }
                            keyFieldName = keyArgumentNode.value.value;
                            typeNameKeyMap.set(node.name.value, keyFieldName);
                        }
                        const fieldDefinitionNodesOfSubgraph = node.fields?.filter(fieldNode => {
                            if (fieldNode.name.value === keyFieldName) {
                                return true;
                            }
                            const joinFieldDirectiveNode = fieldNode.directives?.find(directiveNode => directiveNode.name.value === 'join__field');
                            if (joinFieldDirectiveNode) {
                                const graphArgumentNode = joinFieldDirectiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'graph');
                                if (graphArgumentNode?.value?.kind === graphql_1.Kind.ENUM) {
                                    if (graphArgumentNode.value.value === graphName) {
                                        const requiresArgumentNode = joinFieldDirectiveNode.arguments?.find(argumentNode => argumentNode.name.value === 'requires');
                                        if (requiresArgumentNode?.value?.kind === graphql_1.Kind.STRING) {
                                            let typeNameFieldsKeyMap = typeNameFieldsKeyBySubgraphMap.get(graphName);
                                            if (!typeNameFieldsKeyMap) {
                                                typeNameFieldsKeyMap = new Map();
                                                typeNameFieldsKeyBySubgraphMap.set(graphName, typeNameFieldsKeyMap);
                                            }
                                            let fieldsKeyMap = typeNameFieldsKeyMap.get(node.name.value);
                                            if (!fieldsKeyMap) {
                                                fieldsKeyMap = new Map();
                                                typeNameFieldsKeyMap.set(node.name.value, fieldsKeyMap);
                                            }
                                            fieldsKeyMap.set(fieldNode.name.value, requiresArgumentNode.value.value);
                                        }
                                        return true;
                                    }
                                }
                            }
                            else {
                                return true;
                            }
                            return false;
                        }) || [];
                        const objectTypedDefNodeForSubgraph = {
                            ...node,
                            fields: fieldDefinitionNodesOfSubgraph,
                        };
                        let subgraphTypes = subgraphTypesMap.get(graphName);
                        if (!subgraphTypes) {
                            subgraphTypes = [];
                            subgraphTypesMap.set(graphName, subgraphTypes);
                        }
                        subgraphTypes.push(objectTypedDefNodeForSubgraph);
                    }
                }
            });
        },
    });
    const subschemaMap = new Map();
    for (const [subgraphName, endpoint] of subgraphEndpointMap) {
        const executor = onExecutor({ subgraphName, endpoint });
        const mergeConfig = {};
        const typeNameKeyMap = typeNameKeyBySubgraphMap.get(subgraphName);
        const unionTypeNodes = [];
        if (typeNameKeyMap) {
            const typeNameFieldsKeyMap = typeNameFieldsKeyBySubgraphMap.get(subgraphName);
            for (const [typeName, key] of typeNameKeyMap) {
                const mergedTypeConfig = (mergeConfig[typeName] = {
                    selectionSet: `{ ${key} }`,
                    argsFromKeys: utils_js_1.getArgsFromKeysForFederation,
                    key: utils_js_1.getKeyForFederation,
                    fieldName: `_entities`,
                });
                const keyProps = key.split(' ');
                mergedTypeConfig.dataLoaderOptions = {
                    cacheKeyFn(root) {
                        return keyProps.map(key => root[key]).join(' ');
                    },
                };
                const fieldsKeyMap = typeNameFieldsKeyMap?.get(typeName);
                if (fieldsKeyMap) {
                    const fieldsConfig = (mergedTypeConfig.fields = {});
                    for (const [fieldName, key] of fieldsKeyMap) {
                        fieldsConfig[fieldName] = {
                            selectionSet: `{ ${key} }`,
                            computed: true,
                        };
                    }
                }
                if (typeNameCanonicalMap.get(typeName) === subgraphName) {
                    mergedTypeConfig.canonical = true;
                }
                unionTypeNodes.push({
                    kind: graphql_1.Kind.NAMED_TYPE,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: typeName,
                    },
                });
            }
        }
        const entitiesUnionTypeDefinitionNode = {
            name: {
                kind: graphql_1.Kind.NAME,
                value: '_Entity',
            },
            kind: graphql_1.Kind.UNION_TYPE_DEFINITION,
            types: unionTypeNodes,
        };
        const queryFields = subgraphQueryFieldDefinitionNodes.get(subgraphName) || [];
        const queryWithEntitiesFieldDefinitionNode = {
            name: {
                kind: graphql_1.Kind.NAME,
                value: 'Query',
            },
            kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,
            fields: [
                ...queryFields,
                {
                    kind: graphql_1.Kind.FIELD_DEFINITION,
                    name: {
                        kind: graphql_1.Kind.NAME,
                        value: '_entities',
                    },
                    type: {
                        kind: graphql_1.Kind.NAMED_TYPE,
                        name: {
                            kind: graphql_1.Kind.NAME,
                            value: '_Entity',
                        },
                    },
                    arguments: [
                        {
                            kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                            name: {
                                kind: graphql_1.Kind.NAME,
                                value: 'representations',
                            },
                            type: {
                                kind: graphql_1.Kind.NON_NULL_TYPE,
                                type: {
                                    kind: graphql_1.Kind.LIST_TYPE,
                                    type: {
                                        kind: graphql_1.Kind.NON_NULL_TYPE,
                                        type: {
                                            kind: graphql_1.Kind.NAMED_TYPE,
                                            name: {
                                                kind: graphql_1.Kind.NAME,
                                                value: '_Any',
                                            },
                                        },
                                    },
                                },
                            },
                        },
                    ],
                },
            ],
        };
        const schema = (0, graphql_1.buildASTSchema)({
            kind: graphql_1.Kind.DOCUMENT,
            definitions: [
                ...(subgraphTypesMap.get(subgraphName) || []),
                entitiesUnionTypeDefinitionNode,
                anyTypeDefinitionNode,
                queryWithEntitiesFieldDefinitionNode,
            ],
        }, {
            assumeValidSDL: true,
            assumeValid: true,
        });
        subschemaMap.set(subgraphName, {
            schema,
            executor,
            merge: mergeConfig,
            batch,
        });
    }
    return subschemaMap;
}
exports.getSubschemasFromSupergraphSdl = getSubschemasFromSupergraphSdl;
function getStitchedSchemaFromSupergraphSdl(opts) {
    const subschemaMap = getSubschemasFromSupergraphSdl(opts);
    const supergraphSchema = (0, stitch_1.stitchSchemas)({
        subschemas: [...subschemaMap.values()],
    });
    return (0, utils_js_1.filterInternalFieldsAndTypes)(supergraphSchema);
}
exports.getStitchedSchemaFromSupergraphSdl = getStitchedSchemaFromSupergraphSdl;
const anyTypeDefinitionNode = {
    name: {
        kind: graphql_1.Kind.NAME,
        value: '_Any',
    },
    kind: graphql_1.Kind.SCALAR_TYPE_DEFINITION,
};
